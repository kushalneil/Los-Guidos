using UnityEngine;
using System.Collections.Generic;
using System.Collections;

public class BulletHellMusicalAI : MonoBehaviour {
	
	public int Base;
	public int Step;
	public float BPM;
	public int CurrentStep = 1;
	public int CurrentMeasure =0;
	private int i;
	private float interval;
	private float nextTime;
	//Shoot stuff
	public GameObject shot;
	public Transform[] shotSpawn;
	public int minShot;
	public bool canShoot;
	public bool followTarget;
	public List<int> attackSteps;
	public List<int> attackMeasures;
	HealthSystem health;
	public bool isVisibleCheck;
	public bool isTrackCheck;
	public bool playSound;
	AudioTrackShifter shifter;
	AudioSource src;
	AudioSource soundPlayer;
	public GameObject audCont;
	public List<int> trackIndex;
	public int finalMeasure;
	private bool startMetronome;
	public bool EnemyActivate;
	public GameObject enemyActivator;





	// Use this for initialization
	void Start () 
	{


		src = audCont.GetComponent<AudioSource> ();
		shifter = audCont.GetComponent<AudioTrackShifter> ();
		if (isVisibleCheck)
		GetComponent<IsVisibleTrigger> ().visibleEvent += OnVisible;
		health = GetComponentInParent<HealthSystem> ();
		soundPlayer = GetComponent<AudioSource> ();
		if (EnemyActivate) 
		{
			enemyActivator.GetComponent<EnemyActivator> ().enemyactivateEvent += OnActivate;


		
		}


	}

	public void StartMetronome()
	{
		StopCoroutine("DoTick");
		CurrentStep = 1; 
		var multiplier = Base / 4f;
		var tmpInterval = 60f / BPM;
		interval = tmpInterval / multiplier; 
		nextTime = Time.time; // set the relative time to now
		StartCoroutine("DoTick"); 
	}

	IEnumerator DoTick() // yield methods return IEnumerator
	{
		for (; ;) {


			if (attackSteps.Contains (CurrentStep) && attackMeasures.Contains (CurrentMeasure) && canShoot) 
			
			{
				for (int i = 0; i < shotSpawn.Length; i++) 
				
				{


						
					if(playSound)
					soundPlayer.Play ();
					Instantiate (shot, shotSpawn [i].position, shotSpawn [i].rotation);
					if (i == shotSpawn.Length)
						i = 0;


				}

			}


			nextTime += interval; // add interval to our relative time
			yield return new WaitForSeconds (nextTime - Time.time); // wait for the difference delta between now and expected next time of hit
			CurrentStep++;
			if (CurrentStep > Step) 
			{
				CurrentStep = 1;
				CurrentMeasure++;
			}
		
			if (CurrentMeasure > finalMeasure) 
			{
				CurrentMeasure = 1;
				CurrentStep = 1;

			}
		
		
		
		
		}

	}





	void Update()
	{

		if (trackIndex.Contains(shifter.trackIndex) && src.isPlaying &&!startMetronome) 
		{	

			/*if (playSound) 
			{
				GetComponent<SoundPlayerMetronome> ().StartMetronome ();
				GetComponent<SoundPlayerMetronome> ().active = true;
			}*/
			startMetronome = true;
			if(isTrackCheck)
			canShoot = true;
			StartMetronome ();

		}



	}

	public void OnVisible()
	{

		canShoot = true;
		StartMetronome ();
		/*if (playSound) 
		{
			GetComponent<SoundPlayerMetronome> ().CurrentStep = CurrentStep;
			GetComponent<SoundPlayerMetronome> ().active = true;



		}*/
	}

	public void OnActivate()
	{


		canShoot = true;



  }











}






